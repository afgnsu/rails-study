# Agile Web Development Rails 5 - Note 1

## Part 1 - Getting Started

### 1. Installing Rails

#### macOS

方法1：先安装 brew，再用 brew install ruby，再用 gem 安装 rails

方法2：先安装 rbenv 或 rvm，再用 rbenv 或 rvm 安装 ruby，再用 gem 安装 rails

    $ gem install rails --version=5.0.0.1 --no-ri --no-rdoc

- 要掌握 rvm 或 rbenv 的使用
- 掌握 gem 的使用
- 掌握 bundler 的使用

#### 选择特定的 rails 版本

    $ gem list --local rails
    $ rails _5.0.0.1 --version

### 2. Instant Gratification

    $ bin/rails about
    // or
    $ bundle exec rails about

As you can see from the `bin/` prefix, this is running the rails command from the bin directory. This command is a wrapper, or *binstub*, for the Rails executable.

这里有讲到，在 development 下，修改的代码会立即生效，但是有额外的性能损失，因此在 production 下这个特性默认是关闭的。(原来如此，解答了我之前的一个疑惑，之前我在服务器上直接改代码后，代码并没有生效)

在 view 中显示动态内容的两种方法，以当前时间为例：

1. 在 view 中直接调用 `<%= Time.now %>`
2. 在 controller 中获得时间，赋值给实例变量，在 view 中显示此实例变量的值
       
       // controller
       @time = Time.now
       
       // view
       <%= @time %>

第二种方法的好处是更灵活一些，也是推荐的做法，但方法一也可以用于简单粗暴的实现。

#### Linking Page

尽量不要在 view 中 hardcode 一个链接，像这样：

    <a href="/say/hello">Hello</a>

而是使用 helper 为我们提供的 `link_to` 函数来动态生成链接：

    <%= link_to "Hello", say_hello_path %>
    
helper 函数一般用在 view 模板中，用来帮我们动态生成 html。比如 `link_to` 方法，我能想象它的简略实现：

    def link_to(content, link)
      "<a href=#{link}">#{content}</a>"
    end

`say_hello_path`，这是 rails 自动为路由生成的链接名，对应 'say/hello' 路由。

### 3. The Architecture of Rails Applications

#### MVC

> The *model* is responsible for maintaining the state of the application. Some- times this state is transient, lasting for just a couple of interactions with the user. Sometimes the state is permanent and is stored outside the application, often in a database.

> A *model* is more than data; it enforces all the business rules that apply to that data. For example, if a discount shouldn’t be applied to orders of less than $20, the model enforces the constraint. This makes sense; by putting the implementation of these business rules in the model, we make sure that nothing else in the application can make our data invalid. **The model acts as both a gatekeeper and a data store**.

model 不仅仅是数据，还包括对数据的一些处理，加工。

> The view is responsible for generating a user interface, normally based on data in the model. For example, an online store has a list of products to be displayed on a catalog screen. This list is accessible via the model, but it’s a view that formats the list for the end user. Although the view might present the user with various ways of inputting data, the view itself never handles incoming data. The view’s work is done once the data is displayed. There may well be many views that access the same model data, often for different purposes. The online store has a view that displays product information on a catalog page, and another set of views used by administrators to add and edit products.

view 负责输入 (??) 和输出，展示 model，面向终端用户。

> Controllers orchestrate the application. Controllers receive events from the outside world (normally, user input), interact with the model, and display an appropriate view to the user.

从上面这段描述来看，controller 还负责接受输入，而 view 而只负责展示??

(我可不可以这么理解，view 其实是算作输入源，它接受到输入后，并不作任何处理，而是交给 controller 来处理输入。view 接受输入，controller 处理输入)

其实对于 rails 的 MVC 来说，上面英文的描述其实也没错，因为在 rails 的 MVC 中，controller 是占主导，controller 的输入源来自 url，路由，跟 view 确实没有多少联系。controller 主要是接受这些路由输入，然后操作 model，然后输出到 view。

关于 view 上的按钮点击之类的啊，这类的交互是属于客户端的 mvc 范畴，而不是服务端。为什么 web 诞生的时候，html 没有 button 之类的，所有的可点击的都是 `<a>`，因为这时候还没有网页客户端的概念。这些 `<a>` 产生链接，点击后作为路由传递给服务器的 controller。

![](./art/agile-web-dev-mvc.png)

(我上次说 rails 的 MVC 其实更像 MVP，其实错了，MVP 里，M 和 V 是完全没有联系的，而 rails 的 MVC 里，你是可以在 view 的模板里访问 model 的)

> The controller supplies data to the view, and the controller receives events from the pages generated by the views.

#### Active Record

ORM

#### Action Pack: Then View and Controller

> When you think about it, the view and controller parts of MVC are pretty intimate. The controller supplies data to the view, and the controller receives events from the pages generated by the views. Because of these interactions, support for views and controllers in Rails is bundled into a single component, Action Pack.

View: ERB 模板

Controller: 中心，很多职责，响应路由，管理缓存，管理 helper 模块 (扩展 html 模板)，管理 session

### 4. Introduction to Ruby

Ruby is OO Language.

Ruby 的命名规范：

- 方法名，全小写字母，用 `_` 线分隔多个单词，成员变量用 `@` 加上小写字母；
- 类名，module 名，大写字母开头，双峰写法；
- symbol，符号，`:` 开头。

#### Data Types

- String: `''` 表示 raw string，连 `\n` 都不转义，`""` 会转义，而且支持插值
- Array & Hash
- 正则：/pattern/，str =~ /pattern/

#### Logic

control flow: if / while

blocks and iterators：

block 有 2 种形式，一种是用于单行的 `{}`，一种是用于多行的 `do...end`

在方法中用 yield 来调用传递进来的 block，并且可以在 yield 后面加上变量，从而给 block 传参。

    def wrap &b
        3.times(&b)
    end
    wrap { puts "Hi!" }

在参数中加上 `&` 表示命名的 block。

一个方法只能有一个 block，且这个 block 必须作为最后一个参数。

我觉得可以简单地把 block 理解成一种匿名回调函数。

block 经常和 iterator 一起使用。

Exception：

begin...rescue...end
raise

#### Organizing Structure

class 和 module

**class**

- 实例方法和类方法；
- 实例变量，访问器 (`attr_accessor` ...)

**module**

可以理解成一种带实现的接口，一种 minix。

module 有 2 个作用：

1. 作为 namespace ，防止命名冲突
1. 共享方法，module 里的所有 class 都可以共享此 module 中的所有方法，而不用继承自此 module；另外，class 也可以包含 module，然后使用 module 中的方法。一种 minix 的思想。而不是像 java 这种去实现一种接口的思想。方法注入? 方法扩展?

#### Ruby Idioms

1. empty! empty?
1. a||b, a||=b
1. lambda 操作符 ->，把 block 变成 Proc 的对象 (block, lambda, proc)

----

## Part 2 - Building an Application

### 5. The Depot Application

介绍了我们要练习的项目：一个简单版的购物网站。

初步的流程：

1. Use Cases：允许买者在这个网站上购物，允许卖者在这上面管理商品及订单
1. Page Flow：简单的用户交互流程
1. Data：需要哪些数据

### 6. Task A：Creating the Application

新建项目：

    $ rails new depot

使用 scaffold 快速生成所需文件，用 `generate scaffold` 同时生成 controller，model 和 view。

    $ bin/rails generate scaffold Product \
    title:string descrpition:text image_url:string price:decimal

执行 migration：

    $ bin/rails db:migrate

执行测试：

    $ bin/rails test

使用 `db/seeds.rb` 为数据库初始化一些数据，执行 `rails db:seed` 命令。

美化 products list page，涉及到的一些小技巧和 helper 方法：

1. 在 `application.html.erb` 中使用 `<body class='<%= controller.controller_name %>'>` 为不同的页面指定不同的根 class。
1. `class='<%= cycle(class_a, class_b) %>'`，在列表中交替使用不同的 class。
1. `image_tag`，`truncate`，`strip_tags`，`strip_tags` 从文本中剔除 html tag。

**鉴于对 rails 已经一些了解了，后面的内容不再仔细阅读，已经知道的跳过。**

### 7. TaskB：Validation and Unit Testing

Validate model by `validates` method:

    validates :title, :description, :image_url, presence: true 
    validates :price, numericality: {greater_than_or_equal_to: 0.01} 
    validates :title, uniqueness: true
    validates :image_url, allow_blank: true, format: {
      with: %r{\.(gif|jpg|png)\Z}i,
      message: 'must be a URL for GIF, JPG or PNG image.'
    }

给 product model 增加 validation 后，controller 的单元测试通不过了，修改 controller 的单元测试代码使之通过。

controller 的单元测试主要测试 controller 的各个 action，通过路由来触发，比如 `get products_url`，然后对 response 进行 assertion。比如：

    test "should get index" do 
      get products_url 
      assert_response :success
    end

然后我们编写 model 的单元测试，model 的单元测试测什么呢，主要还是测 model 增加的这些 validation，测试给各属性赋各种值的情况下，model 是否有效。比如，上面的 validations 规定了 title, description, image_url 不能为空，当它们为空时，model 将无效。

    test "product attributes must not be empty" do 
      product = Product.new
      assert product.invalid?
      assert product.errors[:title].any?
      assert product.errors[:description].any? 
      assert product.errors[:price].any? 
      assert product.errors[:image_url].any?
    end

另外，可以在 fixtures 里指定测试环境下数据库的初始值。

单独对 model 进行单元测试的命令：`bin/rails test:models`。

### 8. Task C：Catalog Display

这一章为买者实现了一个商品展示界面，以便他们购买。

增加了一个 StoreController，注意这个 contoller 不像 ProductsController 有直接关联的 model product，store controller 没有，很常见的 session controller 也没有直接关联的 model，静态页面比如 rails tutorial 一书中的 StaticPageController 也没有。所以不是每一个 controller 都有关联的 model。

添加路由 `root "store#index", as: store_index`，其中 `as: store_index` 表示生成的路由名字。

在 application.html.erb 中为所有页面添加了 banner 和 side layout。

为 store controller 添加更多测试用例，使用 `assert_select` 来比较返回的 html 中的内容是否与预期相符。`assert_select` 很强大，要掌握。

最后，学到了一点比较新的内容，就是在 view 模板中使用 `cache` 方法缓存 view 的片断 (view fragment)，提升性能。在 dev 环境要用 `rails dev:cache` 来开启或关闭。

    <% cache @products do %>
      <% @products.each do |product| %>
        <% cache product do %>
          <div class="entry">
            <%= image_tag(product.image_url) %>
            <h3><%= product.title %></h3>
            <%= sanitize(product.description) %>
            <div class="price_line">
              <span class="price"><%= number_to_currency(product.price) %></span>
            </div>
          </div>
        <% end %>
      <% end %>
    <% end %>

### 9. Task D：Cart Creation

本章实现了简易的购物车。

创建 Cart model，表示购物车，将其 id 放到 session 里，表明此购物车只在当前浏览器中有效，关闭重启浏览器后之前购物车中的信息将丢失，实际上新创建了一个购物车。(人个觉得这个 Cart model 没有必要存在，因此里面只存了一个 id，而这个 id 其实可以直接使用 user.id，哦，我明白了，因为目前还没有账户系统，所以要创建出一个新的 cart 来，等有了账户系统后，这个 cart 就可以取消了，但也不排除后面会给它增加更多功能)。

将 cart 的操作作为 module 放在 concern 中，这样所有的 controller 就可以共享：

    module CurrentCart
      private
        def set_cart
          @cart = Cart.find(session[:cart_id])
        rescue ActiveRecord::RecordNotFound
          @cart = Cart.create
          session[:cart_id] = @cart.id
        end
    end

创建 LineItem model，并生成相应的 `line_items` 表，这其实是一个多对多的关联表，将 cart 和 product 关联起来。

如果某个 product 被加入到入购物车，则这个 product 不允许被删除，为 Product 添加 `before_destroy` callback，如果它的 `line_items` 不为空，则用 `throw :abort` 来中断删除操作：

    before_destroy :ensure_not_referenced_by_any_line_item

    private
      def ensure_not_referenced_by_any_line_item
        unless line_items.empty?
          errors.add(:base, 'Line Items present')
          throw :abort
        end
      end

添加 'Add to Cart' 的按钮，因为要使用 POST 请求，而 `<a>` 链接使用的是 GET 请求，因为我们要使用 `button_to` helper 方法，`button_to` 方法将生成 `<form>` 来使用 POST 请求。(如果不用 ajax，form 将是使用 POST 请求的唯一途径，form 同时也来用产生 PATCH/PUT/DELETE 请求，而 `<a>` 则用来产生 GET 请求。)

在测试中，使用 `follow_redirect!` 来得到重定向后的结果。

### 10. Task E：A Smarter Cart

优化购物车，将相同的产品条目合并，因此为 `line_items` 表增加 quantity 列。增加 quantity 后，需要将原来老的数据进行合并，将多条相同条目合并成一条，并修改 quantity 列的值，怎么来做的，以前我的做法是在 `libs/tasks/task.rb` 写一个 task 来做这个事情，从本节学习到，正确的做法应该是写一个实现 `up` 方法的 migration，同时实现一个 `down` 的方法实现逆操作以便进行回滚。

    class CombineItemsInCart < ActiveRecord::Migration[5.0]
      def up
        Cart.all.each do |cart|
          sums = cart.line_items.group(:product_id).sum(:quantity)

          sums.each do |product_id, quantity|
            if quantity > 1
              cart.line_items.where(product_id: product_id).delete_all

              item = cart.line_items.build(product_id: product_id)
              item.quantity = quantity
              item.save!
            end
          end
        end
      end

      def down
        LineItem.where('quantity > 1').each do |item|
          item.quantity.times do 
            LineItem.create(
              cart_id: item.cart_id,
              product_id: item.product_id,
              quantity: 1
            )
          end
          item.destroy
        end
      end
    end

使用 `rails db:migrate:status` 查看当前的 migration 状态。

使用 `rails db:rollback VERSION=xxxx` 进行 migration 的回滚操作，VERSION 指定的是要回滚的那个版本，注意，不是要回滚到的那个版本，就是单指那个版本就被回滚掉。如果不加 VERSION 参数，那么默认是指最近的版本。VERSION 的值可以通过上面的 `rails db:migrate:status` 命令获得。

详细的回滚：[How to rollback a specific migration?](https://stackoverflow.com/questions/3647685/how-to-rollback-a-specific-migration)

#### Handling Errors

这一节的内容对我来说比较有用。有很多新的知识点：

1. `rescue_from ActiveRecord::RecordNotFound, with: :invalid_cart`，在 controller 中用 `recue_from` 捕抓全局异常，这样就不用在每一个方法中单独处理了。
1. `logger.error 'Attempt to access invalid cart #{params[:id]}`，使用 `logger.error` 将错误输出到日志文件里持久保存，日志在 `log/` 目录下。
1. `redirect_to store_index_url, notice: 'Invalid cart'`，redirect 时带上的 notice 参数的值，将存储在 `flash[:notice]` 中，flash 的值存储在 session 中。因此可以跨请求使用。
1. `bin/rails log:clear LOGS=test`，清除 `log/test.log`。

查看了 `test.log` 中的内容后，我理解了我之前的一个疑问，fixture 中自动生成的 product 的两个记录是相同的，而我们在 Product model 中增加了 title 的 uniqueness validataion，那这两个 product 怎么还能插到数据库中呢，原来 fixture 中的数据并没有转换成 model 后再调用 model 的 create 方法来插入数据库，而是直接使用了数据库的 insert into 操作，这样就绕过了 model 的 validation，而在数据库层面，我们并没有为 schema 增加 title 必须唯一的限制。

#### Finishing the Cart

这一节实现清空购物车，实际并不是把 `cart.line_items.clear`，而是直接 `cart.destroy`。

在进行修改或删除数据库数据操作时，安全很重要，比如这里在进行 `cart.destroy` 时，一定要判断要删除的 `cart.id` 是否与 `session[:cart_id]` 相同，否则就把别人的 cart 删除了。

### 11. Task F：Adding a Dash of Ajax

#### Moving the Cart

把 cart 显示到每个页面的左侧栏，这样，cart 部分的内容就需要抽取出来进行复用。利用 view 的 partial 功能，将需要复用的内容抽取成 partial。

此例中，将 line item 的展示抽取成 `_line_item.html.erb` partial，然后在 cart 中直接用 `<%= render cart.line_items %>` 渲染，注意，因为 `line_items` 是可遍历的，因此 render 内部会自动循环渲染；将 cart 的展示抽取成 `_cart.html.erb` partial，然后在 cart 的 show 页面中直接使用 `<%= render @cart %>`；然后在 `applicaton.html.erb` 中 side 栏中就可以也用一行代码 `<%= render @cart %>` 来渲染 cart 了。

因为不是每个页面都可以拿到 @cart 的值，因为在 `application.html.erb` 中渲染 @cart 时，加一个条件判断，只有 @cart 有值时才渲染：

    <% if @cart %>
      <%= render @cart %>
    <% end %>

#### Creating an Ajax-Based Cart

这一小节实现了用 ajax 请求来实现页面的局部刷新，只更新页面 side 栏的 cart 部分内容。

这一小节对我来说觉得很有意思，我原以为一旦用了 ajax，那么就意味着返回的 response 内容就是 json。我以前分析过 github 页面上的请求，有些请求使用了 ajax 请求，返回值却不是 json，当时就觉得好奇。从这一节明白了，原来还可以返回一段 js 代码，然后让浏览器执行，cool！

三步：

1. 在 view 中为需要转成 ajax 的请求加上 `remote:true`：

        <%= button_to 'Add to Cart', line_items_path(product_id: product), remote: true %> 

1. 在 controller 中加上对 js 请求的响应操作：

        respond_to do |format|
          if @line_item.save
            format.html { redirect_to store_index_url }
            format.js
            format.json { render :show, status: :created, location: @line_item }

1. 编写对应的 js view，比如 `create.js.erb`：

        $('#cart').html("<%=j render(@cart) %>")

   j 表示 escape_javascript() 方法的简写，表示把后面 render 出来的 html 内容转换成 javascript 安全的内容。

为什么服务器知道这些请求是在请求 js 代码，而不是 json 呢，通过 chrome 的 devtool 分析这些请求得知，这些请求的 header 中的 accpet 的值是 javascript，而不是 json：

    Accept: */*;q=0.5, text/javascript, application/javascript, application/ecmascript, application/x-ecmascript

#### Highlighing Changes

高亮当前变化的 line item，使用 jquery 的 fade 动画效果，要使用到 jquery-ui 库，通过 `gem 'jquery-ui-rails'` 引入。

    $('#current_item').css({'background-color': '#88ff88'})
                      .animate({'background-color': '#114411'}, 1000);

#### Hiding Empty Cart

定义了一个 helper 方法来隐藏空的 cart，并在 view 中使用：

    # application_helper.rb
    module ApplicationHelper
      def hidden_div_if(condition, attributes = {}, &block)
        if condition
          attributes['style'] = 'display: none'
        end
        content_tag('div', attributes, &block)
      end
    end

    # application.html.erb
    <% if @cart %>
      <%= hidden_div_if(@cart.line_items.empty?, id: 'cart') do %>
        <%= render @cart %>
      <% end %>
    <% end %>

#### Broading Updates with Action Cable

使用 Action Cable，在客户端与服务端之间建立一个长链接 (在 chrome 上使用的是 websocket 技术)，在服务端更新数据后 (比如 product 的 price)，广播到某个 channel 上，客户端从这个 channel 上接收到数据后，用 javascript 更新界面。

步骤：

1. 生成 channel，使用 `rails g channel products` 命令
1. 修改 `product_channel.rb`，定义 `ProductsChannel` 从哪个 channel 订阅

        def subscribed
          stream_from "products"
        end

1. 服务端数据更新后，广播到 channel 上：

        # products_controller.rb
        def update
          respond_to do |format|
            if @product.update(product_params)
              format.html { redirect_to @product, notice: 'Product was successfully updated.' }
              format.json { render :show, status: :ok, location: @product }

              @products = Product.all
              ActionCable.server.broadcast 'products',
                html: render_to_string('store/index', layout: false)

1. 客户端从 channel 接收到新数据后，更新 html：

        // products.coffee
        App.products = App.cable.subscriptions.create "ProductsChannel",
          received: (data) ->
            # Called when there's incoming data on the websocket for this channel
            $(".store #main").html(data.html)
